<script src=lib1.js></script>

<body bgcolor=black>
<center>
<td><canvas id='canvas1' width=800 height=800></canvas></td>
</center>
</body>

<script id='my_vertex_shader' type='x-shader/x-vertex'>
   attribute vec3 aPosition;
   varying   vec3 vPosition;
   void main() {
      gl_Position = vec4(aPosition, 1.0);
      vPosition = aPosition;
   }
</script>

<script id='my_fragment_shader' type='x-shader/x-fragment'>
   precision mediump float;
   uniform float uTime;
   uniform vec3  uCursor;

   //MY UNIFORMS
   uniform float materialShininess;
   uniform vec3 materialSpecularColor;

   varying vec3  vPosition;

   vec4 sphere;
   vec4 spheres[6];
   vec3 material;

   vec3 LArgb, LBrgb, LCrgb;
   vec3 lightLocA, lightLocB, lightLocC;
   vec3 LAdir, LBdir, LCdir;



   uniform struct Light {
   vec3 position;
   vec3 intensities; //a.k.a the color of the light
   float attenuation;
   float ambientCoefficient;
} light;

   float raySphere(vec3 V, vec3 W, vec4 sph) {

      /*
      (W dot W)*(t*t) + 2*(W dot D)*t + (D dot D) - r*r = 0
      SOLVE FOR t (QUADRATIC FORMULA):
      a*(t*t) + b*t + c = 0;
      a = W dot W
      b = 2 * (W dot D)
      c = (D dot D) - r*r

      t0 = ( -b + sqrt( b*b - 4*a*c) ) / 2*a
      t1 = ( -b - sqrt( b*b - 4*a*c) ) / 2*a
      */

      float radius = sph.w;
      vec3 D = V - sph.xyz;
      float A = dot(W, W);
      float B = 2. * (dot(W, D));
      float C = dot(D, D) - radius*radius;
      float discriminant = B*B-4.*A*C;


      //IF t0 AND t1 ARE BOTH POSITIVE, THE RAY INTERSECTS THE SPHERE (THE SMALLER VALUE IS THE NEAREST POINT)
      //IF t0 AND t1 ARE EQUAL, THE RAY IS TANGENT
      //ONE POSITIVE AND ONE NEGATIVE ROOT MEANS THE RAY IS INSIDE THE SPHERE
      //COMPLEX ROOTS MEAN THERE IS NO INTERSECTION (CHECK THE DISCRIMINANT)

      if (discriminant > 0.0)
      {
         float t0 = (-B + sqrt(discriminant)) / 2.;
         float t1 = (-B - sqrt(discriminant)) / 2.;

         if (t0 > 0.0 && t1 > 0.0)
         {
            if (t0 == t1) return t0;
            float t = t0 < t1 ? t0 : t1;
            return t;
        }  

      } else {
         return 10000.;  
      }   
      
   }

   vec3 shadeSphere(vec3 point, vec4 sphere, vec3 material) {
      //SET BASE COLOUR 
      vec3 color = vec3(.2,.2,.2);

      //CAST A RAY FROM THE POINT TO EACH LIGHT
      //IF THE RAY INTERECTS ANY OF THE OTHER SPHERES, THE POINT IS IN SHADOW FOR THAT LIGHT
      vec3 pointToLightDirection = normalize(lightLocB - point);

       //COMPUTE THE SURFACE NORMAL FOR THE POINT (DIRECTION UNIT VECTOR FROM POINT TO CENTER OF SPHERE)
      vec3 normal = normalize( ( point - vec3( sphere.xyz ) ) / sphere.w );

      vec3 ambient = material / 5.;  
      
      vec3 diffuse = vec3(.5, .5, .5);

      color += ambient;

      for (int i = 0; i < 6; i++){

         for (int j = 0; j < 3; j++){


            if (spheres[i].xyz != sphere.xyz){

               float val = raySphere(pointToLightDirection, point, spheres[i]);


               if (val != 10000.) {
                  return color;
                  break;
               } else {
                  color += LArgb * diffuse * max(0., dot(normal, LAdir));
                  color += LBrgb * diffuse * max(0., dot(normal, LBdir));
                  color += LCrgb * diffuse * max(0., dot(normal, LCdir));
               }
            }
         }
      }

      return color;
   }


   void main(void) {
      vec2 c = uCursor.xy;

      // vec2 sphere1Loc = vec2(sin(uTime + 3. * cos(uTime)) , cos(uTime / 2. + 3.) );
      // vec2 sphere2Loc = vec2(3.*sin(uTime) , 3.*cos(uTime)  );
      // vec2 sphere3Loc = vec2(3.*cos(uTime + 2.) , 3.*sin(uTime + 3.) );
      // vec2 sphere4Loc = vec2(3.*sin(uTime / 1.5) , 5.*sin(uTime + 3.) );

      spheres[0] = vec4( sin(uTime + 3. * cos(uTime)) , cos(uTime / 2. + 3.) , -10. + cos(uTime) , 2.*sin(uTime / 5.) + 1. );
      spheres[1] = vec4( 3.  * sin(uTime) , 3.*cos(uTime)  , -10. + sin(uTime * 1.5) , 2.);
      spheres[2] = vec4( 3.  * cos(uTime + 2.) , 3.*sin(uTime + 3.)  , -10. + sin(uTime / 2.) , 2.);
      spheres[3] = vec4( 3.  * sin(uTime / 1.5) , 5.*sin(uTime + 3.)  , -10. + cos(uTime * 1.5) , 1.5*cos(uTime / 4.) + 2.);
      spheres[4] = vec4( 0.5 * sin(uTime), 0.5*cos(uTime /2.) * 2.  , -1.   , 0.5 );
      spheres[5] = vec4( 3.  * sin(uTime) , 2.*sin(uTime - 1.),  -5. + cos(uTime /3.) , 0.5 );

      //SET THE LIGHT COLOUR
      LArgb = vec3(1.,.0,.0);
      LBrgb = vec3(.0,1.,.0);
      LCrgb = vec3(.0,.0,1.);


      lightLocA = vec3(c.x, c.y, 1. -2. * dot(c, c));
      lightLocB = vec3(10.  * sin(uTime) , 10.*cos(uTime)  , -10. + sin(uTime * 1.5));
      lightLocC = vec3(15. * sin(uTime), 15.*cos(uTime), 0.);

      //SET THE LIGHT DIRECTION UNIT VECTOR ACCORDING TO THE CURSOR
      LAdir = normalize(lightLocA);
      LBdir = normalize(lightLocB);
      LCdir = normalize(lightLocC);

      //V REPRESENTS THE EYE POINT, W REPRESENTS THE UNIT VECTOR DIRECTION FROM THE EYE TO THE POINT OF INTERSECTION

      //EYE POSITION REMAINS THE SAME FOR ALL SPHERES
      vec3 V = vec3(0.,0.,1.); 

      // COMPUTE DIRECTION UNIT VECTOR FROM EYE TO POINT
      vec3 W = normalize(vec3(vPosition.x-V.x, vPosition.y - V.y, -V.z));

      vec3 color = vec3(0., 0., 0.);

      //SET THE MATERIAL COLOUR
      material = vec3(.2,.2,0.2);

      float tempT = 10000.;
         for(int i = 0; i < 6; i ++){
            float t = raySphere(V, W, spheres[i]);
            if(t < tempT && t < 10000.){
               tempT = t;
               color = shadeSphere(V + t * W, spheres[i], material);
            } 
         }

      color = pow(color, vec3(.45,.45,.45)); // Do Gamma correction.
      gl_FragColor = vec4(color, 1.);        // Set opacity to 1.
   }
</script>

<script>
//MAKE THE CANVAS THE SIZE OF THE WINDOW
canvas = document.getElementById("canvas1");
canvas.width = document.body.clientHeight; //document.width is obsolete
canvas.height = document.body.clientHeight; //document.height is obsolete
start_gl('canvas1', document.getElementById('my_vertex_shader'  ).innerHTML,
                    document.getElementById('my_fragment_shader').innerHTML);
</script>

